#!groovy
// Copyright 2017 Open Networking Foundation (ONF)
//
// Please refer questions to either the onos test mailing list at <onos-test@onosproject.org>,
// the System Testing Plans and Results wiki page at <https://wiki.onosproject.org/x/voMg>,
// or the System Testing Guide page at <https://wiki.onosproject.org/x/WYQg>
//
//     TestON is free software: you can redistribute it and/or modify
//     it under the terms of the GNU General Public License as published by
//     the Free Software Foundation, either version 2 of the License, or
//     (at your option) any later version.
//
//     TestON is distributed in the hope that it will be useful,
//     but WITHOUT ANY WARRANTY; without even the implied warranty of
//     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//     GNU General Public License for more details.
//
//     You should have received a copy of the GNU General Public License
//     along with TestON.  If not, see <http://www.gnu.org/licenses/>.

// This is the Jenkins script for vm-pipeline-trigger or bm-pipeline-trigger

// set the functions of the dependencies.
funcs = evaluate readTrusted( 'TestON/JenkinsFile/dependencies/JenkinsCommonFuncs.groovy' )
triggerFuncs = evaluate readTrusted( 'TestON/JenkinsFile/dependencies/TriggerFuncs.groovy' )
fileRelated = evaluate readTrusted( 'TestON/JenkinsFile/dependencies/JenkinsPathAndFiles.groovy' )
test_list = evaluate readTrusted( 'TestON/JenkinsFile/dependencies/JenkinsTestONTests.groovy' )

test_list.init()

// set the versions of the onos
fileRelated.init()
current_version = "master"
previous_version = "1.15"
before_previous_version = "2.1"

// init trend graphs to be on VM.
funcs.initializeTrend( "VM" );
triggerFuncs.init( funcs )

// contents for page https://wiki.onosproject.org/display/ONOS/Automated+Test+Schedule
// which will demonstrates the list of the scheduled tests on the days.
wikiContents = ""

// default FUNC,HA to be VM, SCPF,USECASE to be BM.
// SR will not be used in here.
testcases = [
        "FUNC": [ tests: "", nodeName: "VM", wikiContent: "" ],
        "HA": [ tests: "", nodeName: "VM", wikiContent: "" ],
        "SCPF": [ tests: "", nodeName: "BM", wikiContent: "" ],
        "SR": [ tests: "", nodeName: "Fabric", wikiContent: "" ],
        "SRHA": [ tests: "", nodeName: "Fabric", wikiContent: "" ],
        "USECASE": [ tests: "", nodeName: "BM", wikiContent: "" ]
]

// read the parameters from the Jenkins
manually_run = params.manual_run

// set default onos_b to be current_version.
onos_b = current_version
test_branch = ""
onos_tag = params.ONOSTag
isOldFlow = true

// Set tests based on day of week
def now = funcs.getCurrentTime()
print now.toString()
today = now[ Calendar.DAY_OF_WEEK ]

// get branch from parameter if it is manually running
if ( manually_run ){
    onos_b = params.ONOSVersion
}
else {
    // otherwise, the version would be different over the weekend.
    // If today is weekdays, it will be default to current_version.
    if ( today == Calendar.SATURDAY ){
        onos_b = previous_version
    }
    else if ( today == Calendar.SUNDAY ){
        onos_b = before_previous_version
    }
}

// list of the tests to be run will be saved in each choices.
day = ""
SCPF_choices = ""
USECASE_choices = ""
FUNC_choices = ""
HA_choices = ""
SR_choices = ""
SRHA_choices = ""

// init some paths for the files and directories.
stat_graph_generator_file = fileRelated.histogramMultiple
pie_graph_generator_file = fileRelated.pieMultiple
graph_saved_directory = fileRelated.jenkinsWorkspace + "postjob-VM/"

// get post result from the params for manually run.
post_result = params.PostResult

// if automatically run, it will remove the comma at the end after dividing the tests.
if ( !manually_run ){
    testDivider( today )
    FUNC_choices = triggerFuncs.lastCommaRemover( FUNC_choices )
    HA_choices = triggerFuncs.lastCommaRemover( HA_choices )
    SCPF_choices = triggerFuncs.lastCommaRemover( SCPF_choices )
    USECASE_choices = triggerFuncs.lastCommaRemover( USECASE_choices )
    SR_choices = triggerFuncs.lastCommaRemover( SR_choices )
    SRHA_choices = triggerFuncs.lastCommaRemover( SRHA_choices )
}


if ( manually_run ){
    testcases = triggerFuncs.organize_tests( params.Tests, testcases )

    isOldFlow = params.isOldFlow
    println "Tests to be run manually : "
}
else {
    testcases[ "SCPF" ][ "tests" ] = SCPF_choices
    testcases[ "USECASE" ][ "tests" ] = USECASE_choices
    testcases[ "FUNC" ][ "tests" ] = FUNC_choices
    testcases[ "HA" ][ "tests" ] = HA_choices
    testcases[ "SR" ][ "tests" ] = SR_choices
    testcases[ "SRHA" ][ "tests" ] = SRHA_choices
    println "Defaulting to " + day + " tests:"
}

triggerFuncs.print_tests( testcases )

def runTest = [
        "VM": [ : ],
        "BM": [ : ]
]

// set the test running function into the dictionary.
for ( String test in testcases.keySet() ){
    println test
    if ( testcases[ test ][ "tests" ] != "" ){
        runTest[ testcases[ test ][ "nodeName" ] ][ test ] = triggerFuncs.
                trigger_pipeline( onos_b, testcases[ test ][ "tests" ], testcases[ test ][ "nodeName" ], test,
                                  manually_run, onos_tag )
    }
}
def finalList = [ : ]

// get the name of the job.
jobName = env.JOB_NAME

// first set the list of the functions to be run.
finalList[ "VM" ] = triggerFuncs.runTestSeq( runTest[ "VM" ] )
finalList[ "BM" ] = triggerFuncs.runTestSeq( runTest[ "BM" ] )

// if first two character of the job name is vm, only call VM.
// else, only on BM
if ( jobName.take( 2 ) == "vm" ){
    finalList[ "VM" ].call()
}
else {
    finalList[ "BM" ].call()
}

// If it is automated running, it will generate the stats graph on VM.
if ( !manually_run ){
    funcs.generateStatGraph( "TestStation-VMs",
                             funcs.branchWithPrefix( onos_b ),
                             stat_graph_generator_file,
                             pie_graph_generator_file,
                             graph_saved_directory )
}

// function that will divide tests depends on which day it is.
def testDivider( today ){
    todayStr = today.toString()

    dayMap = [ ( Calendar.MONDAY )    : "mon",
               ( Calendar.TUESDAY )   : "tue",
               ( Calendar.WEDNESDAY ) : "wed",
               ( Calendar.THURSDAY )  : "thu",
               ( Calendar.FRIDAY )    : "fri",
               ( Calendar.SATURDAY )  : "sat",
               ( Calendar.SUNDAY )    : "sun" ]
    fullDayMap = [ ( Calendar.MONDAY )    : "Monday",
                   ( Calendar.TUESDAY )   : "Tuesday",
                   ( Calendar.WEDNESDAY ) : "Wednesday",
                   ( Calendar.THURSDAY )  : "Thursday",
                   ( Calendar.FRIDAY )    : "Friday",
                   ( Calendar.SATURDAY )  : "Saturday",
                   ( Calendar.SUNDAY )    : "Sunday" ]

    if ( today == Calendar.MONDAY ){
        initHtmlForWiki()
        day = fullDayMap[ today ]
        for ( key in dayMap.keySet() ){
            buildDay( dayMap[ key ], false )
        }
        closeHtmlForWiki()
        postToWiki( wikiContents )
        slackSend( color: '#FFD988',
                   message: "Tests to be run this weekdays : \n" +
                            triggerFuncs.printDaysForTest() )
    } else {
        day = fullDayMap[ today ]
        buildDay( dayMap[ today ], true )
    }
}

def buildDay( dayStr, getResult ){
    addingHeader( "FUNC" )
    FUNC_choices += adder( "FUNC", dayStr, getResult )
    closingHeader( "FUNC" )
    addingHeader( "HA" )
    HA_choices += adder( "HA", dayStr, getResult )
    closingHeader( "HA" )
    addingHeader( "SCPF" )
    SCPF_choices += adder( "SCPF", dayStr, getResult )
    closingHeader( "SCPF" )
    addingHeader( "SR" )
    SR_choices += adder( "SR", dayStr, false )
    closingHeader( "SR" )
    addingHeader( "SRHA" )
    SRHA_choices += adder( "SRHA", dayStr, false )
    closingHeader( "SRHA" )
    addingHeader( "USECASE" )
    USECASE_choices += adder( "USECASE", dayStr, getResult )
    closingHeader( "USECASE" )
}

// adder that will return the list of the tests.
def adder( category, day, getResult ){
    // category : the category of the test which will be either FUNC,HA,SR...
    // day : the day you are trying to add (m,t,w,th... )
    // getResult : if want to get the list of the test to be run. False will return empty list.
    //             And once the list is empty, it will not be run.
    def result = ""
    selectedTests = test_list.getTestsFromCategory( category, test_list.getTestsFromDay( day, onos_b ) )

    for ( String test in selectedTests.keySet() ){
        if ( getResult ){
            result += test + ","
        }
        // make HTML columns for wiki page on schedule.
        makeHtmlColList( category, test )
    }
    return result
}

// Initial part of the wiki page.
def initHtmlForWiki(){
    wikiContents = '''
    <table class="wrapped confluenceTable">
        <colgroup>
              <col />
              <col />
              <col />
              <col />
              <col />
              <col />
        </colgroup>
        <tbody>
            <tr>
                <th colspan="1" class="confluenceTh">
                    <br />
                </th>
                <th class="confluenceTh"><p>Monday</p></th>
                <th class="confluenceTh"><p>Tuesday</p></th>
                <th class="confluenceTh"><p>Wednesday</p></th>
                <th class="confluenceTh"><p>Thursday</p></th>
                <th class="confluenceTh"><p>Friday</p></th>
                <th class="confluenceTh"><p>Saturday</p></th>
                <th class="confluenceTh"><p>Sunday</p></th>
            </tr>'''
    for ( String test in testcases.keySet() ){
        testcases[ test ][ 'wikiContent' ] = '''
            <tr>
                <th colspan="1" class="confluenceTh">''' + test + '''</th>'''
    }
}

// adding header functionality.
def addingHeader( testCategory ){
    testcases[ testCategory ][ 'wikiContent' ] += '''
                <td class="confluenceTd">
                    <ul>'''
}

// making column list for html
def makeHtmlColList( testCategory, testName ){
    testcases[ testCategory ][ 'wikiContent' ] += '''
                        <li>''' + testName + '''</li>'''

}

// closing the header for html
def closingHeader( testCategory ){
    testcases[ testCategory ][ 'wikiContent' ] += '''
                    </ul>
                </td>'''
}

// close the html for the wiki page.
def closeHtmlForWiki(){
    for ( String test in testcases.keySet() ){
        wikiContents += testcases[ test ][ 'wikiContent' ]
        wikiContents += '''
            </tr>'''
    }
    wikiContents += '''
        </tbody>
    </table>
    <p><strong>Everyday</strong>, all SegmentRouting tests are built and run on every supported branch.</p>
    <p>On <strong>Weekdays</strong>, all the other tests are built and run on the master branch.</p>
    <p>On <strong>Saturdays</strong>, all the other tests are built and run on the ''' +
                    funcs.branchWithPrefix( previous_version ) + ''' branch.</p>
    <p>On <strong>Sundays</strong>, all the other tests are built and run on the ''' +
                    funcs.branchWithPrefix( before_previous_version ) + ''' branch.</p>'''
}

// post the result to wiki page using publish to confluence.
def postToWiki( contents ){
    node( testMachine ) {
        workspace = fileRelated.jenkinsWorkspace + "all-pipeline-trigger/"
        filename = "jenkinsSchedule.txt"
        writeFile file: workspace + filename, text: contents
        funcs.publishToConfluence( "false", "true",
                                   "Automated Test Schedule",
                                   workspace + filename )
    }
}
