#!groovy
// Copyright 2017 Open Networking Foundation (ONF)
//
// Please refer questions to either the onos test mailing list at <onos-test@onosproject.org>,
// the System Testing Plans and Results wiki page at <https://wiki.onosproject.org/x/voMg>,
// or the System Testing Guide page at <https://wiki.onosproject.org/x/WYQg>
//
//     TestON is free software: you can redistribute it and/or modify
//     it under the terms of the GNU General Public License as published by
//     the Free Software Foundation, either version 2 of the License, or
//     (at your option) any later version.
//
//     TestON is distributed in the hope that it will be useful,
//     but WITHOUT ANY WARRANTY; without even the implied warranty of
//     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//     GNU General Public License for more details.
//
//     You should have received a copy of the GNU General Public License
//     along with TestON.  If not, see <http://www.gnu.org/licenses/>.

// This is the Jenkins script for the fabric-pipeline-trigger

// init dependencies functions
funcs = evaluate readTrusted( 'TestON/JenkinsFile/dependencies/JenkinsCommonFuncs.groovy' )
test_list = evaluate readTrusted( 'TestON/JenkinsFile/dependencies/JenkinsTestONTests.groovy' )
triggerFuncs = evaluate readTrusted( 'TestON/JenkinsFile/dependencies/TriggerFuncs.groovy' )
fileRelated = evaluate readTrusted( 'TestON/JenkinsFile/dependencies/JenkinsPathAndFiles.groovy' )

fileRelated.init()
test_list.init()

// Function that will initialize the configuration of the Fabric.
funcs.initializeTrend( "Fabric" )
funcs.initialize( "Fabric" )
triggerFuncs.init( funcs )

// Wiki contents is the contents for https://wiki.onosproject.org/display/ONOS/Automated+Test+Schedule
// It will only be used by the VM_BMJenkinsTrigger not in here.
wikiContents = ""

all_testcases = [:]

// set some variables from the parameter
manually_run = params.manual_run
onos_tag = params.ONOSTag
isOldFlow = true

// Set tests based on day of week
def now = funcs.getCurrentTime()
print now.toString()
today = now[ Calendar.DAY_OF_WEEK ]

dayMap = [ ( Calendar.MONDAY )    : "mon",
           ( Calendar.TUESDAY )   : "tue",
           ( Calendar.WEDNESDAY ) : "wed",
           ( Calendar.THURSDAY )  : "thu",
           ( Calendar.FRIDAY )    : "fri",
           ( Calendar.SATURDAY )  : "sat",
           ( Calendar.SUNDAY )    : "sun" ]
fullDayMap = [ ( Calendar.MONDAY )    : "Monday",
               ( Calendar.TUESDAY )   : "Tuesday",
               ( Calendar.WEDNESDAY ) : "Wednesday",
               ( Calendar.THURSDAY )  : "Thursday",
               ( Calendar.FRIDAY )    : "Friday",
               ( Calendar.SATURDAY )  : "Saturday",
               ( Calendar.SUNDAY )    : "Sunday" ]


// if it is manually run, it will set the onos version to be what it was passed by.
// Currently, SR-pipeline-manually is not supported due to the special way of it is executed.
if ( manually_run ){
    onos_branches = params.branches.tokenize( "\n;, " )
} else {
    onos_branches = test_list.getBranchesFromDay( today )
}

testcases_template = [
        "FUNC": [ tests: "", nodeName: "VM", wikiContent: "" ],
        "HA": [ tests: "", nodeName: "VM", wikiContent: "" ],
        "SCPF": [ tests: "", nodeName: "BM", wikiContent: "" ],
        "SR": [ tests: "", nodeName: "Fabric", wikiContent: "" ],
        "SRHA": [ tests: "", nodeName: "Fabric", wikiContent: "" ],
        "USECASE": [ tests: "", nodeName: "BM", wikiContent: "" ]
]

for ( String b in onos_branches ){
    all_testcases.put( b, testcases_template )
}

day = ""

// initialize the graph generating files.
stat_graph_generator_file = fileRelated.histogramMultiple
pie_graph_generator_file = fileRelated.pieMultiple
graph_saved_directory = fileRelated.jenkinsWorkspace + "postjob-Fabric/"

// get the post_result. This will be affected only for the manual runs.
post_result = params.PostResult

if ( manually_run ){
    for ( String b in onos_branches ){
        all_testcases[ b ] = triggerFuncs.organize_tests( params.Tests, all_testcases[ b ] )
    }
    isOldFlow = params.isOldFlow
    println "Tests to be run manually : "
} else {
    // If it is automated running, it will post the beginning message to the channel.
    slackSend( channel: 'sr-failures', color: '#03CD9F',
               message: ":sparkles:" * 16 + "\n" +
                        "Starting tests on : " + now.toString() +
                        "\n" + ":sparkles:" * 16 )

    for ( String b in onos_branches ){
        // set the list of the tests to run.
        all_testcases[ b ][ "SR" ][ "tests" ] += adder( "SR", dayMap[ today ], true, b )
        all_testcases[ b ][ "SRHA" ][ "tests" ] += adder( "SRHA", dayMap[ today ], true, b )
    }
    println "Defaulting to " + day + " tests:"
}

// print out the list of the test to run on Jenkins
for ( String b in onos_branches ){
    triggerFuncs.print_tests( all_testcases[ b ] )
}

// This will hold the block of code to be run.
def runTest = [
        "Fabric": [ : ],
        "Fabric2": [ : ],
        "Fabric3": [ : ],
        "Fabric4": [ : ]
]
for ( String b in onos_branches ){
    if ( manually_run ){
        // for manual run situation.
        for ( String test in all_testcases[ b ].keySet() ){
            println test
            // Unless the list of the tests on the test category is empty, it will save the block of code to run in dictionary.
            if ( all_testcases[ b ][ test ][ "tests" ] != "" ){
                runTest[ all_testcases[ b ][ test ][ "nodeName" ][ nodeOn( b ) ] ][ test ] = triggerFuncs.
                        trigger_pipeline( b,
                                          all_testcases[ b ][ test ][ "tests" ],
                                          all_testcases[ b ][ test ][ "nodeName" ][ nodeOn( b ) ],
                                          test,
                                          manually_run,
                                          onos_tag )
            }
        }
    }
    else {
        // for automated situation, it will save current version to Fabric4, previous version to Fabric2 and before_previous_version to Fabric3.
        runTest[ "Fabric4" ][ "SR" ] = triggerFuncs.trigger_pipeline( "master",
                                                                      all_testcases[ b ][ "SR" ][ "tests" ],
                                                                      all_testcases[ b ][ "SR" ][ "nodeName" ][ 2 ],
                                                                      "SR",
                                                                      manually_run, onos_tag )
        runTest[ "Fabric2" ][ "SR" ] = triggerFuncs.trigger_pipeline( test_list.convertBranchCodeToBranch( "onos-2.x" ),
                                                                      all_testcases[ b ][ "SR" ][ "tests" ],
                                                                      all_testcases[ b ][ "SR" ][ "nodeName" ][ 0 ],
                                                                      "SR",
                                                                      manually_run, onos_tag )
        runTest[ "Fabric3" ][ "SR" ] = triggerFuncs.trigger_pipeline( test_list.convertBranchCodeToBranch( "onos-1.x" ),
                                                                      all_testcases[ b ][ "SR" ][ "tests" ],
                                                                      all_testcases[ b ][ "SR" ][ "nodeName" ][ 1 ],
                                                                      "SR",
                                                                      manually_run, onos_tag )
        runTest[ "Fabric" ][ "SRHA" ] = triggerFuncs.trigger_pipeline( "master",
                                                                       all_testcases[ b ][ "SRHA" ][ "tests" ],
                                                                       all_testcases[ b ][ "SRHA" ][ "nodeName" ],
                                                                       "SRHA",
                                                                       manually_run, onos_tag )
    }
}

def finalList = [ : ]

// It will run each category of test to run sequentially on each branch.
finalList[ "Fabric" ] = triggerFuncs.runTestSeq( runTest[ "Fabric" ] )
finalList[ "Fabric2" ] = triggerFuncs.runTestSeq( runTest[ "Fabric2" ] )
finalList[ "Fabric3" ] = triggerFuncs.runTestSeq( runTest[ "Fabric3" ] )
finalList[ "Fabric4" ] = triggerFuncs.runTestSeq( runTest[ "Fabric4" ] )

// It will then run Fabric2, Fabric3 and Fabric4 concurrently.
// In our case,
//                      ----> Fabric4 : current_version
// This pipeline -----> ----> Fabric2 : previous_version
//                      ----> Fabric3 : before_previous_version
parallel finalList

// Way we are generating pie graphs. not supported in SegmentRouting yet.
/*
if ( !manually_run ){
    funcs.generateStatGraph( "TestStation-Fabric4s",
                             funcs.branchWithPrefix( current_version ),
                             AllTheTests,
                             stat_graph_generator_file,
                             pie_graph_generator_file,
                             graph_saved_directory )
    funcs.generateStatGraph( "TestStation-Fabric2s",
                             funcs.branchWithPrefix( previous_version ),
                             AllTheTests,
                             stat_graph_generator_file,
                             pie_graph_generator_file,
                             graph_saved_directory )
    funcs.generateStatGraph( "TestStation-Fabric3s",
                             funcs.branchWithPrefix( before_previous_version ),
                             AllTheTests,
                             stat_graph_generator_file,
                             pie_graph_generator_file,
                             graph_saved_directory )
}*/

// Way to add list of the tests with specific category to the result
def adder( category, day, getResult, branch ){
    // category : the category of the test which will be either FUNC,HA,SR...
    // day : the day you are trying to add (m,t,w,th... )
    // getResult : if want to get the list of the test to be run. False will return empty list.
    //             And once the list is empty, it will not be run.
    def result = ""
    selectedTests = test_list.getTestsFromCategory( category, test_list.getTestsFromDay( day, branch ) )

    for ( String test in selectedTests.keySet() ){
        if ( getResult ){
            result += test + ","
        }
    }
    return result
}

// check which node is on.
def nodeOn( branch ){
    switch ( branch ){
        case "master": return 2
        case convertBranchCodeToBranch( "onos-2.x" ): return 0
        case convertBranchCodeToBranch( "onos-1.x" ): return 1
        default: return 3
    }
}
